var C = (n) => {
  throw TypeError(n);
};
var H = (n, e, t) => e.has(n) || C("Cannot " + t);
var s = (n, e, t) => (H(n, e, "read from private field"), t ? t.call(n) : e.get(n)), o = (n, e, t) => e.has(n) ? C("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), h = (n, e, t, r) => (H(n, e, "write to private field"), r ? r.call(n, t) : e.set(n, t), t), O = (n, e, t) => (H(n, e, "access private method"), t);
const u = Object.freeze({
  ALL: 0,
  FALLBACK: 1,
  PROPERTY: 2
});
function q(n, e, t = u.ALL) {
  let r = null;
  if (t != u.FALLBACK) {
    const i = this.asProperty(e, "title");
    i && i.trim() != "" && (r = i);
  }
  if (!r && t != u.PROPERTY) {
    const i = this.asFallback(n, "title");
    i && i.trim() !== "" && (r = i);
  }
  return r ? r.substring(0, 65).trim() : null;
}
function W(n, e, t = u.ALL) {
  let r = null;
  if (t != u.FALLBACK) {
    const i = this.asProperty(e, "desc");
    i && i.trim() != "" && (r = i);
  }
  if (!r && t != u.PROPERTY) {
    const i = this.asFallback(n, "desc");
    i && i.trim() !== "" && (r = i);
  }
  return r ? r.substring(0, 120).trim() : null;
}
class a extends Error {
  constructor(e, t) {
    super(`[NEXTPAGE_ERR_${e}]: ` + t), this.code = e;
  }
}
function B(n, e, t = u.ALL) {
  let r = null;
  if (t != u.FALLBACK) {
    let i = e.querySelector("[np-action]");
    if (i) {
      let l = i.getAttribute("np-action");
      if (l && l.trim() !== "" && l.includes(">"))
        r = l;
      else {
        const c = i.innerText, f = i.href;
        c && c.trim() != "" && f && f.trim() != "" && (r = `${c.trim()} > ${f.trim()}`);
      }
    }
  }
  if (t != u.PROPERTY && !r) {
    const i = this.asFallback(n, "action");
    i && i.trim() !== "" && (r = i);
  }
  return !r || r.trim() == "" ? null : K(r);
}
function K(n) {
  const e = n.split(">");
  return e.length != 2 ? new a(2, `Value found but could not parse "action" field, invalid syntax. Expected format: <label> > <url> | Got: "${n}"`) : e[0].trim() == "" || e[1].trim() == "" ? new a(2, "Value found but but either label or url is not defined") : {
    label: e[0].substring(0, 30).trim(),
    url: e[1].trim()
  };
}
function j(n, e, t = u.ALL) {
  let r = null;
  if (t != u.FALLBACK) {
    const i = this.asProperty(e, "article");
    i && i.trim() != "" && (r = i);
  }
  if (!r && t != u.PROPERTY) {
    const i = this.asFallback(n, "article");
    i && i.trim() !== "" && (r = i);
  }
  return r ? r.slice(0, 200).trim() : null;
}
function D(n, e, t = u.ALL) {
  let r = [];
  if (t != u.FALLBACK) {
    const i = [...e.querySelectorAll("[np-img]")];
    i && i.length > 0 && i.forEach((l) => {
      let c = Y(l);
      c && r.push(c);
    });
  }
  if (t != u.PROPERTY && r.length == 0) {
    const i = this.asFallback(n, "img");
    i && i.trim() !== "" && (r = i.split(",", 4));
  }
  return r.length == 0 ? null : r.slice(0, 4);
}
function Y(n) {
  let e = null;
  return e = n.getAttribute("np-img"), e && e.trim() != "" || (e = n.src, e && e.trim() != "") ? e : null;
}
var b;
class U {
  constructor() {
    /** @type {Record<string, CallableFunction>} */
    o(this, b, {});
    this.register("title", q), this.register("desc", W), this.register("img", D), this.register("action", B), this.register("article", j);
  }
  /**
   * Retrieves the explicit or implicit value of the FieldType withing the contextElement.
   * 
   * @param {HTMLElement} contextElement 
   * @param {string} fieldTypeName 
   * @returns {string|null}
   */
  asProperty(e, t) {
    let r = null;
    const i = e.querySelector(`[np-${t}]`);
    if (!i)
      return null;
    const l = i.getAttribute(`np-${t}`);
    return l && l.trim() != "" && (r = l), r || (r = i.innerText), !r || r.trim() == "" ? null : r.trim();
  }
  /**
   * Retrieves the fallback value of the FieldType from the DOM
   * 
   * @param {Document} DOM 
   * @param {string} fieldTypeName 
   * @returns {string|null}
   */
  asFallback(e, t) {
    const r = e.head.querySelector(`meta[name='np:${t}']`);
    if (!r)
      return null;
    const i = r.content;
    return !i || i.trim() == "" ? null : i.trim();
  }
  /**
   * Registers the FieldType
   * 
   * @param {string} fieldTypeName 
   * @param {CallableFunction} callback 
   * @return {any}
   */
  register(e, t) {
    s(this, b)[e] = t.bind(this);
  }
  /**
   * Runs registered FieldTypes and returns their value(s) 
   * 
   * @param {string} fieldTypeName 
   * @param {Document} DOM 
   * @param {Element|null} contextElement 
   * @param {number} queryMode 
   * @returns {any}
   */
  call(e, t, r, i = u.ALL) {
    return this.has(e) ? s(this, b)[e](t, r, i) : new a(3, `Field type “${e}” was not found in the registry. Ensure the field type is registered before use.`);
  }
  /**
   * Returns true if FieldType is registered
   * 
   * @param {string} fieldTypeName 
   * @returns {boolean}
   */
  has(e) {
    return e in s(this, b);
  }
}
b = new WeakMap();
function G() {
  return {
    title: !0,
    desc: !0,
    action: !1
  };
}
function I() {
  return {
    img: !0
  };
}
function z() {
  return {
    article: !0
  };
}
var p, k;
class _ {
  constructor() {
    /** @type {Record<string, CallableFunction>} */
    o(this, p, {});
    /** @type {Array<String>} */
    o(this, k, []);
    this.register("basic", G), this.register("article", z), this.register("gallery", I);
  }
  /**
   * Registers ViewType
   * 
   * @param {string} viewTypeName 
   * @param {CallableFunction} callback 
   */
  register(e, t) {
    s(this, p)[e] = t, s(this, k).push(e);
  }
  /**
   * Returns the relevant FieldTypes for the ViewType
   * 
   * @param {string} viewTypeName 
   * @returns {object|NextPageError}
   */
  call(e) {
    if (!this.has(e))
      return new a(3, `View type “${e}” was not found in the registry. Ensure the view type is registered before use.`);
    let t = s(this, p).basic(), r = {};
    return e !== "basic" && (r = s(this, p)[e]()), {
      ...t,
      ...r
    };
  }
  /**
   * Returns true if ViewType is registered
   * 
   * @param {string} viewTypeName 
   * @returns {boolean}
   */
  has(e) {
    return e in s(this, p);
  }
  /**
   * 
   * @returns {Array<String>}
   */
  getRegistry() {
    return s(this, k);
  }
}
p = new WeakMap(), k = new WeakMap();
var g;
class Q {
  /**
   * 
   * @param {ViewTypeRegistry} viewTypeRegistry 
   */
  constructor(e) {
    o(this, g);
    h(this, g, e);
  }
  /**
   * Retrieves the explicitly defined ViewType of the node
   * 
   * @param {Element} contextElement 
   * @returns {string|null}
   */
  getExplicitViewType(e) {
    var r;
    const t = (r = e.querySelector("[np-view]")) == null ? void 0 : r.getAttribute("np-view");
    return !t || !s(this, g).has(t) ? null : t;
  }
  /**
   * Returns the implicit view
   * 
   * Loops through all ViewTypes and checks weather the ViewTypes required fields are defined within the Node element
   * @param {Element} contextElement 
   * @returns {string|null}
   */
  getImplicitViewType(e) {
    let t = null;
    const r = [...s(this, g).getRegistry()].reverse();
    for (let i = 0; i < r.length; i++) {
      let l = r[i], c = !0;
      for (const [f, A] of Object.entries(s(this, g).call(l))) {
        if (A == !1)
          continue;
        if (e.querySelectorAll(`[np-${f}]`).length == 0) {
          c = !1;
          break;
        }
      }
      if (c) {
        t = l;
        break;
      }
    }
    return t;
  }
}
g = new WeakMap();
var R, E, P, M;
class X {
  /**
   * 
   * @param {ViewTypeRegistry} viewTypeRegistry 
   * @param {FieldTypeRegistry} fieldTypeRegistry 
   */
  constructor(e, t) {
    o(this, P);
    /** @type {ViewTypeRegistry} */
    o(this, R);
    /** @type {FieldTypeRegistry} */
    o(this, E);
    h(this, R, t), h(this, E, e);
  }
  /**
   * Converts HTML to document object.
   * 
   * @param {string} HTML 
   * @returns {Document|NextPageError}
   */
  HTMLToDocument(e) {
    const t = new DOMParser().parseFromString(e, "text/html");
    return t.documentElement.nodeName === "parsererror" ? new a(0, 'The string provided in parameter "HTML" is invalid. Expected a well-formed HTML document.') : t;
  }
  /**
   * Return the Element that declares the Node
   * 
   * @param {Document} DOM 
   * @param {string} targetNodeName 
   * @returns {Element|null}
   */
  getNodeElement(e, t) {
    let r = e.body.querySelector(`[np-node="${t}"]`);
    return r ? O(this, P, M).call(this, r) : null;
  }
  /**
  * Retrieves all the relevant fields defined by the ViewType for the Node
  * 
  * @param {Document} DOM 
  * @param {Element} contextElement 
  * @param {string} viewTypeName 
  * @returns {object|NextPageError}
  */
  buildNode(e, t, r, i = u.ALL) {
    const l = s(this, R).call(r);
    let c = {};
    if (l instanceof a)
      return l;
    for (const [f, A] of Object.entries(l)) {
      const F = s(this, E).call(f, e, t, i);
      if (A && F instanceof a || A && F == null)
        return F;
      c[f] = F;
    }
    return c.view = r, c;
  }
}
R = new WeakMap(), E = new WeakMap(), P = new WeakSet(), /**
* Return Node without any child nodes declarations
* 
* @param {Element} contextElement 
* @returns {Element}
*/
M = function(e) {
  e.querySelectorAll("[np-node]").forEach((r) => r.remove());
  let t = document.createElement("div");
  return t.innerHTML = e.outerHTML, t;
};
var y, w, V, $;
class J {
  /**
   * @param {FieldTypeRegistry} fieldTypeRegistry 
   * @param {ViewTypeRegistry} viewTypeRegistry 
   * @param {DocumentParser} documentParser 
   */
  constructor(e, t, r) {
    /** @type {FieldTypeRegistry} */
    o(this, y);
    /** @type {ViewTypeRegistry} */
    o(this, w);
    /** @type {DocumentParser} */
    o(this, V);
    o(this, $, ["primary"]);
    h(this, y, e), h(this, w, t), h(this, V, r);
  }
  /**
   * Returns a valid failover node
   * 
   * @param {Document} DOM 
   * @returns {Element|null}
   */
  resolveToFailover(e) {
    if (!e.body)
      return null;
    for (const [t, r] of Object.entries(s(this, $))) {
      const i = s(this, V).getNodeElement(e, r);
      if (i)
        return i;
    }
    return null;
  }
  /**
   * Returns a valid fallback node
   * 
   * @param {Document} DOM 
   * @returns {object|NextPageError}
   */
  resolveToFallback(e) {
    if (!e.head)
      return new a(1, "The document provided does not contain a <head> tag. Please provide a Document with a valid <head> element.");
    let t = s(this, y).asFallback(e, "view");
    (!t || !s(this, w).has(t)) && (t = "basic");
    const r = s(this, w).call(t);
    let i = {};
    for (const [l, c] of Object.entries(r)) {
      const f = s(this, y).call(l, e, null, u.FALLBACK);
      if (c && f instanceof a || c && f == null)
        break;
      i[l] = f;
    }
    return Object.keys(i).length == 0 ? new a(1, "The webpage does not contain a valid fallback node. Ensure a valid fallback node is defined in the document.") : (i.view = t, i);
  }
}
y = new WeakMap(), w = new WeakMap(), V = new WeakMap(), $ = new WeakMap();
var x, S;
class Z {
  constructor() {
    o(this, x);
  }
  /**
   * Retrieve HTML string from URL
   * 
   * @param {string} URL 
   * @returns {Promise<string|NextPageError>}
   */
  async getWebpage(e) {
    let t;
    if (!O(this, x, S).call(this, e))
      return new a(0, "The format of the URL provided is invalid. Ensure the value is a properly formatted URL string.");
    try {
      const r = await fetch(
        e,
        {
          method: "GET",
          headers: { accept: "text/html, application/xhtml+xml" },
          cache: "no-store"
        }
      );
      if (!r.ok)
        return new a(2, `The webpage could not be retrieved. Verify that the URL is correct and the server returned a valid response (status: ${r.status}).`);
      const i = await r.text();
      if (!i.trim())
        return new a(1, "The response body is empty. Ensure the server returns valid data in the response.");
      t = i;
    } catch (r) {
      return new a(2, `Failed to fetch resource from <${e}>. Verify that the URL is reachable and the server is responding correctly.

 ${r}`);
    }
    return t;
  }
}
x = new WeakSet(), /**
 * Returns true if URL is valid
 * 
 * @param {string} URL 
 * @returns {boolean}
 */
S = function(e) {
  return /^(https?:\/\/)?([\w.-]+)\.([a-z]{2,6})(:\d{1,5})?(\/[^\s]*)?$/i.test(e);
};
var T, v, d, m, L;
class ee {
  constructor() {
    /** @type {FieldTypeRegistry} */
    o(this, T);
    /** @type {ViewTypeResolver} */
    o(this, v);
    /** @type {DocumentParser} */
    o(this, d);
    /** @type {FailoverEngine} */
    o(this, m);
    /** @type {HTTPClient} */
    o(this, L);
    const e = new _();
    h(this, T, new U()), h(this, d, new X(s(this, T), e)), h(this, m, new J(s(this, T), e, s(this, d))), h(this, v, new Q(e)), h(this, L, new Z());
  }
  /**
   * Retrieve a node through an HTML string
   * 
   * @param {string} HTML 
   * @param {string} targetNodeName 
   * @returns {object|NextPageError}
   */
  queryWithHTML(e, t = "primary") {
    if (e && e.trim() == "")
      return new a(0, 'The parameter "HTML" must not be empty. Please provide valid HTML content.');
    const r = s(this, d).HTMLToDocument(e);
    if (r instanceof a)
      return r;
    (!t || t.trim() == "") && (t = "primary");
    let i = s(this, d).getNodeElement(r, t);
    if (i || (i = s(this, m).resolveToFailover(r)), !i)
      return s(this, m).resolveToFallback(r);
    let l = s(this, v).getExplicitViewType(i);
    l || (l = s(this, v).getImplicitViewType(i)), l || (l = "basic");
    let c = s(this, d).buildNode(r, i, l);
    return c || new a(3, `Found node "${t}", but it’s missing required fields needed by its view type. Verify that all expected field types are defined.`);
  }
  /**
   * Allows for querying node with URL
   * 
   * @param {string} URL 
   * @param {string} targetNodeName 
   * @returns {Promise<object | NextPageError>}
   */
  async queryWithURL(e, t = "") {
    const r = await s(this, L).getWebpage(e);
    return r instanceof a ? r : this.queryWithHTML(r, t);
  }
  /**
   * Returns fallback node from document
   * 
   * @param {string} HTML 
   * 
   * @returns {object|NextPageError}
   */
  getFallbackWithHTML(e) {
    if (e && e.trim() == "")
      return new a(0, 'The parameter "HTML" must not be empty. Please provide valid HTML content.');
    const t = s(this, d).HTMLToDocument(e);
    return t instanceof a ? t : s(this, m).resolveToFallback(t);
  }
  /**
   * Returns fallback node from URL
   * 
   * @param {string} URL 
   * @returns {Promise<object | NextPageError>}
   */
  async getFallbackWithURL(e) {
    const t = await s(this, L).getWebpage(e);
    return t instanceof a ? t : this.getFallbackWithHTML(t);
  }
}
T = new WeakMap(), v = new WeakMap(), d = new WeakMap(), m = new WeakMap(), L = new WeakMap();
export {
  ee as default
};
